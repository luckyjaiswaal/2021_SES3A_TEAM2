{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = global || self, factory(global['fast-equals'] = {}));\n})(this, function (exports) {\n  'use strict';\n\n  var HAS_WEAKSET_SUPPORT = typeof WeakSet === 'function';\n  var keys = Object.keys;\n  /**\r\n   * @function addToCache\r\n   *\r\n   * add object to cache if an object\r\n   *\r\n   * @param value the value to potentially add to cache\r\n   * @param cache the cache to add to\r\n   */\n\n  function addToCache(value, cache) {\n    if (value && typeof value === 'object') {\n      cache.add(value);\n    }\n  }\n  /**\r\n   * @function hasPair\r\n   *\r\n   * @description\r\n   * does the `pairToMatch` exist in the list of `pairs` provided based on the\r\n   * `isEqual` check\r\n   *\r\n   * @param pairs the pairs to compare against\r\n   * @param pairToMatch the pair to match\r\n   * @param isEqual the equality comparator used\r\n   * @param meta the meta provided\r\n   * @returns does the pair exist in the pairs provided\r\n   */\n\n\n  function hasPair(pairs, pairToMatch, isEqual, meta) {\n    var length = pairs.length;\n    var pair;\n\n    for (var index = 0; index < length; index++) {\n      pair = pairs[index];\n\n      if (isEqual(pair[0], pairToMatch[0], meta) && isEqual(pair[1], pairToMatch[1], meta)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\r\n   * @function hasValue\r\n   *\r\n   * @description\r\n   * does the `valueToMatch` exist in the list of `values` provided based on the\r\n   * `isEqual` check\r\n   *\r\n   * @param values the values to compare against\r\n   * @param valueToMatch the value to match\r\n   * @param isEqual the equality comparator used\r\n   * @param meta the meta provided\r\n   * @returns does the value exist in the values provided\r\n   */\n\n\n  function hasValue(values, valueToMatch, isEqual, meta) {\n    var length = values.length;\n\n    for (var index = 0; index < length; index++) {\n      if (isEqual(values[index], valueToMatch, meta)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\r\n   * @function sameValueZeroEqual\r\n   *\r\n   * @description\r\n   * are the values passed strictly equal or both NaN\r\n   *\r\n   * @param a the value to compare against\r\n   * @param b the value to test\r\n   * @returns are the values equal by the SameValueZero principle\r\n   */\n\n\n  function sameValueZeroEqual(a, b) {\n    return a === b || a !== a && b !== b;\n  }\n  /**\r\n   * @function isPlainObject\r\n   *\r\n   * @description\r\n   * is the value a plain object\r\n   *\r\n   * @param value the value to test\r\n   * @returns is the value a plain object\r\n   */\n\n\n  function isPlainObject(value) {\n    return value.constructor === Object || value.constructor == null;\n  }\n  /**\r\n   * @function isPromiseLike\r\n   *\r\n   * @description\r\n   * is the value promise-like (meaning it is thenable)\r\n   *\r\n   * @param value the value to test\r\n   * @returns is the value promise-like\r\n   */\n\n\n  function isPromiseLike(value) {\n    return !!value && typeof value.then === 'function';\n  }\n  /**\r\n   * @function isReactElement\r\n   *\r\n   * @description\r\n   * is the value passed a react element\r\n   *\r\n   * @param value the value to test\r\n   * @returns is the value a react element\r\n   */\n\n\n  function isReactElement(value) {\n    return !!(value && value.$$typeof);\n  }\n  /**\r\n   * @function getNewCacheFallback\r\n   *\r\n   * @description\r\n   * in cases where WeakSet is not supported, creates a new custom\r\n   * object that mimics the necessary API aspects for cache purposes\r\n   *\r\n   * @returns the new cache object\r\n   */\n\n\n  function getNewCacheFallback() {\n    return Object.create({\n      _values: [],\n      add: function (value) {\n        this._values.push(value);\n      },\n      has: function (value) {\n        return this._values.indexOf(value) !== -1;\n      }\n    });\n  }\n  /**\r\n   * @function getNewCache\r\n   *\r\n   * @description\r\n   * get a new cache object to prevent circular references\r\n   *\r\n   * @returns the new cache object\r\n   */\n\n\n  var getNewCache = function (canUseWeakMap) {\n    if (canUseWeakMap) {\n      return function _getNewCache() {\n        return new WeakSet();\n      };\n    }\n\n    return getNewCacheFallback;\n  }(HAS_WEAKSET_SUPPORT);\n  /**\r\n   * @function createCircularEqualCreator\r\n   *\r\n   * @description\r\n   * create a custom isEqual handler specific to circular objects\r\n   *\r\n   * @param [isEqual] the isEqual comparator to use instead of isDeepEqual\r\n   * @returns the method to create the `isEqual` function\r\n   */\n\n\n  function createCircularEqualCreator(isEqual) {\n    return function createCircularEqual(comparator) {\n      var _comparator = isEqual || comparator;\n\n      return function circularEqual(a, b, cache) {\n        if (cache === void 0) {\n          cache = getNewCache();\n        }\n\n        var hasA = cache.has(a);\n        var hasB = cache.has(b);\n\n        if (hasA || hasB) {\n          return hasA && hasB;\n        }\n\n        addToCache(a, cache);\n        addToCache(b, cache);\n        return _comparator(a, b, cache);\n      };\n    };\n  }\n  /**\r\n   * @function toPairs\r\n   *\r\n   * @description\r\n   * convert the map passed into pairs (meaning an array of [key, value] tuples)\r\n   *\r\n   * @param map the map to convert to [key, value] pairs (entries)\r\n   * @returns the [key, value] pairs\r\n   */\n\n\n  function toPairs(map) {\n    var pairs = new Array(map.size);\n    var index = 0;\n    map.forEach(function (value, key) {\n      pairs[index++] = [key, value];\n    });\n    return pairs;\n  }\n  /**\r\n   * @function toValues\r\n   *\r\n   * @description\r\n   * convert the set passed into values\r\n   *\r\n   * @param set the set to convert to values\r\n   * @returns the values\r\n   */\n\n\n  function toValues(set) {\n    var values = new Array(set.size);\n    var index = 0;\n    set.forEach(function (value) {\n      values[index++] = value;\n    });\n    return values;\n  }\n  /**\r\n   * @function areArraysEqual\r\n   *\r\n   * @description\r\n   * are the arrays equal in value\r\n   *\r\n   * @param a the array to test\r\n   * @param b the array to test against\r\n   * @param isEqual the comparator to determine equality\r\n   * @param meta the meta object to pass through\r\n   * @returns are the arrays equal\r\n   */\n\n\n  function areArraysEqual(a, b, isEqual, meta) {\n    var length = a.length;\n\n    if (b.length !== length) {\n      return false;\n    }\n\n    for (var index = 0; index < length; index++) {\n      if (!isEqual(a[index], b[index], meta)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\r\n   * @function areMapsEqual\r\n   *\r\n   * @description\r\n   * are the maps equal in value\r\n   *\r\n   * @param a the map to test\r\n   * @param b the map to test against\r\n   * @param isEqual the comparator to determine equality\r\n   * @param meta the meta map to pass through\r\n   * @returns are the maps equal\r\n   */\n\n\n  function areMapsEqual(a, b, isEqual, meta) {\n    if (a.size !== b.size) {\n      return false;\n    }\n\n    var pairsA = toPairs(a);\n    var pairsB = toPairs(b);\n    var length = pairsA.length;\n\n    for (var index = 0; index < length; index++) {\n      if (!hasPair(pairsB, pairsA[index], isEqual, meta) || !hasPair(pairsA, pairsB[index], isEqual, meta)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  var OWNER = '_owner';\n  var hasOwnProperty = Function.prototype.bind.call(Function.prototype.call, Object.prototype.hasOwnProperty);\n  /**\r\n   * @function areObjectsEqual\r\n   *\r\n   * @description\r\n   * are the objects equal in value\r\n   *\r\n   * @param a the object to test\r\n   * @param b the object to test against\r\n   * @param isEqual the comparator to determine equality\r\n   * @param meta the meta object to pass through\r\n   * @returns are the objects equal\r\n   */\n\n  function areObjectsEqual(a, b, isEqual, meta) {\n    var keysA = keys(a);\n    var length = keysA.length;\n\n    if (keys(b).length !== length) {\n      return false;\n    }\n\n    var key;\n\n    for (var index = 0; index < length; index++) {\n      key = keysA[index];\n\n      if (!hasOwnProperty(b, key)) {\n        return false;\n      }\n\n      if (key === OWNER && isReactElement(a)) {\n        if (!isReactElement(b)) {\n          return false;\n        }\n      } else if (!isEqual(a[key], b[key], meta)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\r\n   * @function areRegExpsEqual\r\n   *\r\n   * @description\r\n   * are the regExps equal in value\r\n   *\r\n   * @param a the regExp to test\r\n   * @param b the regExp to test agains\r\n   * @returns are the regExps equal\r\n   */\n\n\n  function areRegExpsEqual(a, b) {\n    return a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.unicode === b.unicode && a.sticky === b.sticky && a.lastIndex === b.lastIndex;\n  }\n  /**\r\n   * @function areSetsEqual\r\n   *\r\n   * @description\r\n   * are the sets equal in value\r\n   *\r\n   * @param a the set to test\r\n   * @param b the set to test against\r\n   * @param isEqual the comparator to determine equality\r\n   * @param meta the meta set to pass through\r\n   * @returns are the sets equal\r\n   */\n\n\n  function areSetsEqual(a, b, isEqual, meta) {\n    if (a.size !== b.size) {\n      return false;\n    }\n\n    var valuesA = toValues(a);\n    var valuesB = toValues(b);\n    var length = valuesA.length;\n\n    for (var index = 0; index < length; index++) {\n      if (!hasValue(valuesB, valuesA[index], isEqual, meta) || !hasValue(valuesA, valuesB[index], isEqual, meta)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  var isArray = Array.isArray;\n  var HAS_MAP_SUPPORT = typeof Map === 'function';\n  var HAS_SET_SUPPORT = typeof Set === 'function';\n  var OBJECT_TYPEOF = 'object';\n\n  function createComparator(createIsEqual) {\n    var isEqual =\n    /* eslint-disable no-use-before-define */\n    typeof createIsEqual === 'function' ? createIsEqual(comparator) : comparator;\n    /* eslint-enable */\n\n    /**\r\n     * @function comparator\r\n     *\r\n     * @description\r\n     * compare the value of the two objects and return true if they are equivalent in values\r\n     *\r\n     * @param a the value to test against\r\n     * @param b the value to test\r\n     * @param [meta] an optional meta object that is passed through to all equality test calls\r\n     * @returns are a and b equivalent in value\r\n     */\n\n    function comparator(a, b, meta) {\n      if (sameValueZeroEqual(a, b)) {\n        return true;\n      }\n\n      if (a && b && typeof a === OBJECT_TYPEOF && typeof b === OBJECT_TYPEOF) {\n        if (isPlainObject(a) && isPlainObject(b)) {\n          return areObjectsEqual(a, b, isEqual, meta);\n        }\n\n        var arrayA = isArray(a);\n        var arrayB = isArray(b);\n\n        if (arrayA || arrayB) {\n          return arrayA === arrayB && areArraysEqual(a, b, isEqual, meta);\n        }\n\n        var aDate = a instanceof Date;\n        var bDate = b instanceof Date;\n\n        if (aDate || bDate) {\n          return aDate === bDate && sameValueZeroEqual(a.getTime(), b.getTime());\n        }\n\n        var aRegExp = a instanceof RegExp;\n        var bRegExp = b instanceof RegExp;\n\n        if (aRegExp || bRegExp) {\n          return aRegExp === bRegExp && areRegExpsEqual(a, b);\n        }\n\n        if (isPromiseLike(a) || isPromiseLike(b)) {\n          return a === b;\n        }\n\n        if (HAS_MAP_SUPPORT) {\n          var aMap = a instanceof Map;\n          var bMap = b instanceof Map;\n\n          if (aMap || bMap) {\n            return aMap === bMap && areMapsEqual(a, b, isEqual, meta);\n          }\n        }\n\n        if (HAS_SET_SUPPORT) {\n          var aSet = a instanceof Set;\n          var bSet = b instanceof Set;\n\n          if (aSet || bSet) {\n            return aSet === bSet && areSetsEqual(a, b, isEqual, meta);\n          }\n        }\n\n        return areObjectsEqual(a, b, isEqual, meta);\n      }\n\n      return false;\n    }\n\n    return comparator;\n  } // comparator\n\n\n  var deepEqual = createComparator();\n  var shallowEqual = createComparator(function () {\n    return sameValueZeroEqual;\n  });\n  var circularDeepEqual = createComparator(createCircularEqualCreator());\n  var circularShallowEqual = createComparator(createCircularEqualCreator(sameValueZeroEqual));\n  exports.circularDeepEqual = circularDeepEqual;\n  exports.circularShallowEqual = circularShallowEqual;\n  exports.createCustomEqual = createComparator;\n  exports.deepEqual = deepEqual;\n  exports.sameValueZeroEqual = sameValueZeroEqual;\n  exports.shallowEqual = shallowEqual;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"sources":["../src/utils.ts","../src/comparator.ts","../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["const HAS_WEAKSET_SUPPORT = typeof WeakSet === 'function';\n\nconst { keys } = Object;\n\ntype Cache = {\n  add: (value: any) => void;\n  has: (value: any) => boolean;\n};\n\n/**\n * @function addToCache\n *\n * add object to cache if an object\n *\n * @param value the value to potentially add to cache\n * @param cache the cache to add to\n */\nexport function addToCache(value: any, cache: Cache) {\n  if (value && typeof value === 'object') {\n    cache.add(value);\n  }\n}\n\nexport type EqualityComparator = (a: any, b: any, meta?: any) => boolean;\n\n/**\n * @function hasPair\n *\n * @description\n * does the `pairToMatch` exist in the list of `pairs` provided based on the\n * `isEqual` check\n *\n * @param pairs the pairs to compare against\n * @param pairToMatch the pair to match\n * @param isEqual the equality comparator used\n * @param meta the meta provided\n * @returns does the pair exist in the pairs provided\n */\nexport function hasPair(\n  pairs: [any, any][],\n  pairToMatch: [any, any],\n  isEqual: EqualityComparator,\n  meta: any,\n) {\n  const { length } = pairs;\n\n  let pair: [any, any];\n\n  for (let index = 0; index < length; index++) {\n    pair = pairs[index];\n\n    if (\n      isEqual(pair[0], pairToMatch[0], meta) &&\n      isEqual(pair[1], pairToMatch[1], meta)\n    ) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * @function hasValue\n *\n * @description\n * does the `valueToMatch` exist in the list of `values` provided based on the\n * `isEqual` check\n *\n * @param values the values to compare against\n * @param valueToMatch the value to match\n * @param isEqual the equality comparator used\n * @param meta the meta provided\n * @returns does the value exist in the values provided\n */\nexport function hasValue(\n  values: any[],\n  valueToMatch: any,\n  isEqual: EqualityComparator,\n  meta: any,\n) {\n  const { length } = values;\n\n  for (let index = 0; index < length; index++) {\n    if (isEqual(values[index], valueToMatch, meta)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * @function sameValueZeroEqual\n *\n * @description\n * are the values passed strictly equal or both NaN\n *\n * @param a the value to compare against\n * @param b the value to test\n * @returns are the values equal by the SameValueZero principle\n */\nexport function sameValueZeroEqual(a: any, b: any) {\n  return a === b || (a !== a && b !== b);\n}\n\n/**\n * @function isPlainObject\n *\n * @description\n * is the value a plain object\n *\n * @param value the value to test\n * @returns is the value a plain object\n */\nexport function isPlainObject(value: any) {\n  return value.constructor === Object || value.constructor == null;\n}\n\n/**\n * @function isPromiseLike\n *\n * @description\n * is the value promise-like (meaning it is thenable)\n *\n * @param value the value to test\n * @returns is the value promise-like\n */\nexport function isPromiseLike(value: any) {\n  return !!value && typeof value.then === 'function';\n}\n\n/**\n * @function isReactElement\n *\n * @description\n * is the value passed a react element\n *\n * @param value the value to test\n * @returns is the value a react element\n */\nexport function isReactElement(value: any) {\n  return !!(value && value.$$typeof);\n}\n\n/**\n * @function getNewCacheFallback\n *\n * @description\n * in cases where WeakSet is not supported, creates a new custom\n * object that mimics the necessary API aspects for cache purposes\n *\n * @returns the new cache object\n */\nexport function getNewCacheFallback(): Cache {\n  return Object.create({\n    _values: [],\n\n    add(value: any) {\n      this._values.push(value);\n    },\n\n    has(value: any) {\n      return this._values.indexOf(value) !== -1;\n    },\n  });\n}\n\n/**\n * @function getNewCache\n *\n * @description\n * get a new cache object to prevent circular references\n *\n * @returns the new cache object\n */\nexport const getNewCache = ((canUseWeakMap: boolean) => {\n  if (canUseWeakMap) {\n    return function _getNewCache(): Cache {\n      return new WeakSet();\n    };\n  }\n\n  return getNewCacheFallback;\n})(HAS_WEAKSET_SUPPORT);\n\n/**\n * @function createCircularEqualCreator\n *\n * @description\n * create a custom isEqual handler specific to circular objects\n *\n * @param [isEqual] the isEqual comparator to use instead of isDeepEqual\n * @returns the method to create the `isEqual` function\n */\nexport function createCircularEqualCreator(isEqual?: EqualityComparator) {\n  return function createCircularEqual(comparator: EqualityComparator) {\n    const _comparator = isEqual || comparator;\n\n    return function circularEqual(\n      a: any,\n      b: any,\n      cache: Cache = getNewCache(),\n    ) {\n      const hasA = cache.has(a);\n      const hasB = cache.has(b);\n\n      if (hasA || hasB) {\n        return hasA && hasB;\n      }\n\n      addToCache(a, cache);\n      addToCache(b, cache);\n\n      return _comparator(a, b, cache);\n    };\n  };\n}\n\n/**\n * @function toPairs\n *\n * @description\n * convert the map passed into pairs (meaning an array of [key, value] tuples)\n *\n * @param map the map to convert to [key, value] pairs (entries)\n * @returns the [key, value] pairs\n */\nexport function toPairs(map: Map<any, any>): [any, any][] {\n  const pairs = new Array(map.size);\n\n  let index = 0;\n\n  map.forEach((value, key) => {\n    pairs[index++] = [key, value];\n  });\n\n  return pairs;\n}\n\n/**\n * @function toValues\n *\n * @description\n * convert the set passed into values\n *\n * @param set the set to convert to values\n * @returns the values\n */\nexport function toValues(set: Set<any>) {\n  const values = new Array(set.size);\n\n  let index = 0;\n\n  set.forEach((value) => {\n    values[index++] = value;\n  });\n\n  return values;\n}\n\n/**\n * @function areArraysEqual\n *\n * @description\n * are the arrays equal in value\n *\n * @param a the array to test\n * @param b the array to test against\n * @param isEqual the comparator to determine equality\n * @param meta the meta object to pass through\n * @returns are the arrays equal\n */\nexport function areArraysEqual(\n  a: any[],\n  b: any[],\n  isEqual: EqualityComparator,\n  meta: any,\n) {\n  const { length } = a;\n\n  if (b.length !== length) {\n    return false;\n  }\n\n  for (let index = 0; index < length; index++) {\n    if (!isEqual(a[index], b[index], meta)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * @function areMapsEqual\n *\n * @description\n * are the maps equal in value\n *\n * @param a the map to test\n * @param b the map to test against\n * @param isEqual the comparator to determine equality\n * @param meta the meta map to pass through\n * @returns are the maps equal\n */\nexport function areMapsEqual(\n  a: Map<any, any>,\n  b: Map<any, any>,\n  isEqual: EqualityComparator,\n  meta: any,\n) {\n  if (a.size !== b.size) {\n    return false;\n  }\n\n  const pairsA = toPairs(a);\n  const pairsB = toPairs(b);\n\n  const { length } = pairsA;\n\n  for (let index = 0; index < length; index++) {\n    if (\n      !hasPair(pairsB, pairsA[index], isEqual, meta) ||\n      !hasPair(pairsA, pairsB[index], isEqual, meta)\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\ntype Dictionary<Type> = {\n  [key: string]: Type;\n  [index: number]: Type;\n};\n\nconst OWNER = '_owner';\n\nconst hasOwnProperty = Function.prototype.bind.call(\n  Function.prototype.call,\n  Object.prototype.hasOwnProperty,\n);\n\n/**\n * @function areObjectsEqual\n *\n * @description\n * are the objects equal in value\n *\n * @param a the object to test\n * @param b the object to test against\n * @param isEqual the comparator to determine equality\n * @param meta the meta object to pass through\n * @returns are the objects equal\n */\nexport function areObjectsEqual(\n  a: Dictionary<any>,\n  b: Dictionary<any>,\n  isEqual: EqualityComparator,\n  meta: any,\n) {\n  const keysA = keys(a);\n\n  const { length } = keysA;\n\n  if (keys(b).length !== length) {\n    return false;\n  }\n\n  let key: string;\n\n  for (let index = 0; index < length; index++) {\n    key = keysA[index];\n\n    if (!hasOwnProperty(b, key)) {\n      return false;\n    }\n\n    if (key === OWNER && isReactElement(a)) {\n      if (!isReactElement(b)) {\n        return false;\n      }\n    } else if (!isEqual(a[key], b[key], meta)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * @function areRegExpsEqual\n *\n * @description\n * are the regExps equal in value\n *\n * @param a the regExp to test\n * @param b the regExp to test agains\n * @returns are the regExps equal\n */\nexport function areRegExpsEqual(a: RegExp, b: RegExp) {\n  return (\n    a.source === b.source &&\n    a.global === b.global &&\n    a.ignoreCase === b.ignoreCase &&\n    a.multiline === b.multiline &&\n    a.unicode === b.unicode &&\n    a.sticky === b.sticky &&\n    a.lastIndex === b.lastIndex\n  );\n}\n\n/**\n * @function areSetsEqual\n *\n * @description\n * are the sets equal in value\n *\n * @param a the set to test\n * @param b the set to test against\n * @param isEqual the comparator to determine equality\n * @param meta the meta set to pass through\n * @returns are the sets equal\n */\nexport function areSetsEqual(\n  a: Set<any>,\n  b: Set<any>,\n  isEqual: EqualityComparator,\n  meta: any,\n) {\n  if (a.size !== b.size) {\n    return false;\n  }\n\n  const valuesA = toValues(a);\n  const valuesB = toValues(b);\n\n  const { length } = valuesA;\n\n  for (let index = 0; index < length; index++) {\n    if (\n      !hasValue(valuesB, valuesA[index], isEqual, meta) ||\n      !hasValue(valuesA, valuesB[index], isEqual, meta)\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import {\n  EqualityComparator,\n  areArraysEqual,\n  areMapsEqual,\n  areObjectsEqual,\n  areRegExpsEqual,\n  areSetsEqual,\n  isPlainObject,\n  isPromiseLike,\n  sameValueZeroEqual,\n} from './utils';\n\nconst { isArray } = Array;\n\nconst HAS_MAP_SUPPORT = typeof Map === 'function';\nconst HAS_SET_SUPPORT = typeof Set === 'function';\n\nconst OBJECT_TYPEOF = 'object';\n\ntype EqualityComparatorCreator = (fn: EqualityComparator) => EqualityComparator;\n\nexport function createComparator(createIsEqual?: EqualityComparatorCreator) {\n  const isEqual: EqualityComparator =\n    /* eslint-disable no-use-before-define */\n    typeof createIsEqual === 'function'\n      ? createIsEqual(comparator)\n      : comparator;\n  /* eslint-enable */\n\n  /**\n   * @function comparator\n   *\n   * @description\n   * compare the value of the two objects and return true if they are equivalent in values\n   *\n   * @param a the value to test against\n   * @param b the value to test\n   * @param [meta] an optional meta object that is passed through to all equality test calls\n   * @returns are a and b equivalent in value\n   */\n  function comparator(a: any, b: any, meta?: any) {\n    if (sameValueZeroEqual(a, b)) {\n      return true;\n    }\n\n    if (a && b && typeof a === OBJECT_TYPEOF && typeof b === OBJECT_TYPEOF) {\n      if (isPlainObject(a) && isPlainObject(b)) {\n        return areObjectsEqual(a, b, isEqual, meta);\n      }\n\n      const arrayA = isArray(a);\n      const arrayB = isArray(b);\n\n      if (arrayA || arrayB) {\n        return arrayA === arrayB && areArraysEqual(a, b, isEqual, meta);\n      }\n\n      const aDate = a instanceof Date;\n      const bDate = b instanceof Date;\n\n      if (aDate || bDate) {\n        return aDate === bDate && sameValueZeroEqual(a.getTime(), b.getTime());\n      }\n\n      const aRegExp = a instanceof RegExp;\n      const bRegExp = b instanceof RegExp;\n\n      if (aRegExp || bRegExp) {\n        return aRegExp === bRegExp && areRegExpsEqual(a, b);\n      }\n\n      if (isPromiseLike(a) || isPromiseLike(b)) {\n        return a === b;\n      }\n\n      if (HAS_MAP_SUPPORT) {\n        const aMap = a instanceof Map;\n        const bMap = b instanceof Map;\n\n        if (aMap || bMap) {\n          return aMap === bMap && areMapsEqual(a, b, isEqual, meta);\n        }\n      }\n\n      if (HAS_SET_SUPPORT) {\n        const aSet = a instanceof Set;\n        const bSet = b instanceof Set;\n\n        if (aSet || bSet) {\n          return aSet === bSet && areSetsEqual(a, b, isEqual, meta);\n        }\n      }\n\n      return areObjectsEqual(a, b, isEqual, meta);\n    }\n\n    return false;\n  }\n\n  return comparator;\n}\n","// comparator\nimport { createComparator } from './comparator';\n\n// utils\nimport { createCircularEqualCreator, sameValueZeroEqual } from './utils';\n\nexport { createComparator as createCustomEqual, sameValueZeroEqual };\n\nexport const deepEqual = createComparator();\nexport const shallowEqual = createComparator(() => sameValueZeroEqual);\n\nexport const circularDeepEqual = createComparator(createCircularEqualCreator());\nexport const circularShallowEqual = createComparator(\n  createCircularEqualCreator(sameValueZeroEqual),\n);\n"]},"metadata":{},"sourceType":"script"}